# Exchange-CPP Development Plan

## 项目目标

使用 C++ 1:1 重写 exchange-core，保持相同的功能和性能特性。

## 核心依赖映射

### Java → C++ 技术栈映射

| Java (exchange-core) | C++ (exchange-cpp) | 说明 |
|---------------------|-------------------|------|
| LMAX Disruptor | disruptor-cpp | 无锁环形缓冲区，线程间通信 |
| Eclipse Collections | C++ STL + 自定义集合 | 高效集合数据结构 |
| Real Logic Agrona | 自定义实现 | 内存布局、缓存行对齐 |
| OpenHFT Chronicle | 待定 | 持久化、序列化 |
| LZ4 Java | lz4 (C库) | 压缩算法 |
| Adaptive Radix Trees | 自定义实现或第三方 | 高效索引结构 |

## 开发阶段

### Phase 1: 项目初始化与依赖集成 ✅

- [x] 创建项目结构
- [ ] 集成 disruptor-cpp 作为子模块
- [ ] 配置 CMake 构建系统
- [ ] 设置测试框架 (Google Test)
- [ ] 设置基准测试框架 (Google Benchmark)

### Phase 2: 核心数据模型

- [ ] **Order 模型**: 订单数据结构 (限价单、市价单、止损单等)
- [ ] **Trade 模型**: 成交记录
- [ ] **OrderBook 模型**: 订单簿数据结构
- [ ] **Symbol 模型**: 交易对定义
- [ ] **User 模型**: 用户账户信息

### Phase 3: 订单簿管理

- [ ] **OrderBook 实现**: 
  - 买卖盘维护 (Price-Time Priority)
  - 订单插入/删除/修改
  - 深度查询 (L2 Market Data)
- [ ] **价格索引**: 高效的价格查找结构
- [ ] **订单匹配逻辑**: 价格优先、时间优先

### Phase 4: 撮合引擎核心

- [ ] **Matching Engine**:
  - 订单接收与验证
  - 撮合算法实现
  - 成交生成
  - 订单状态管理
- [ ] **事件处理**: 基于 disruptor-cpp 的事件流
- [ ] **并发控制**: 多线程安全设计

### Phase 5: 风险管理

- [ ] **余额检查**: 账户余额验证
- [ ] **保证金计算**: 杠杆交易支持
- [ ] **仓位限制**: 单用户/全局限制
- [ ] **风险控制规则**: 各种风控策略

### Phase 6: API 层

- [ ] **命令接口**: 下单、撤单、查询等
- [ ] **查询接口**: 订单状态、账户信息、市场数据
- [ ] **报告接口**: 交易报告、余额报告等

### Phase 7: 持久化与恢复

- [ ] **事件持久化**: 关键事件写入日志
- [ ] **状态快照**: 定期保存系统状态
- [ ] **恢复机制**: 从快照和日志恢复

### Phase 8: 性能优化

- [ ] **内存池**: 减少内存分配开销
- [ ] **缓存优化**: CPU 缓存友好设计
- [ ] **NUMA 优化**: 多 NUMA 节点支持
- [ ] **SIMD 优化**: 向量化关键路径
- [ ] **性能基准测试**: 与 Java 版本对比

### Phase 9: 测试与文档

- [ ] **单元测试**: 覆盖所有核心模块
- [ ] **集成测试**: 端到端测试
- [ ] **压力测试**: 高并发场景测试
- [ ] **API 文档**: 使用 Doxygen 生成
- [ ] **架构文档**: 系统设计说明

## 关键技术决策

### 1. 内存管理
- 使用内存池减少分配开销
- 考虑使用 `std::pmr` (C++17) 或自定义分配器
- 避免频繁的堆分配

### 2. 并发模型
- 使用 disruptor-cpp 的 ring buffer 作为核心通信机制
- 单生产者多消费者模式 (SPMC) 用于订单处理
- 多生产者单消费者模式 (MPSC) 用于结果聚合

### 3. 数据结构选择
- OrderBook: 考虑使用 `std::map` 或自定义红黑树
- 价格索引: 考虑 Adaptive Radix Tree 或跳表
- 订单队列: 使用 disruptor-cpp ring buffer

### 4. 序列化
- 考虑使用 FlatBuffers 或 Cap'n Proto 用于跨进程通信
- 内部使用二进制格式，避免 JSON 解析开销

## 性能目标

- **吞吐量**: 与 Java 版本相当或更好
- **延迟**: P99 延迟 < 10μs (本地测试)
- **内存**: 内存占用 < Java 版本的 50%

## 开发优先级

1. **P0 (核心功能)**:
   - 订单簿管理
   - 基本撮合逻辑
   - 单线程版本先实现

2. **P1 (关键功能)**:
   - 多线程并发处理
   - 风险管理基础功能
   - 基本 API

3. **P2 (增强功能)**:
   - 完整风险管理
   - 持久化
   - 性能优化

4. **P3 (扩展功能)**:
   - 高级报告功能
   - 集群支持
   - 更多交易类型

## 里程碑

- **M1**: 完成单线程撮合引擎，通过基础测试
- **M2**: 完成多线程版本，性能达到 Java 版本 80%
- **M3**: 完成所有核心功能，性能达到或超过 Java 版本
- **M4**: 生产就绪，完整测试和文档

## 注意事项

1. **1:1 移植**: 保持与 Java 版本相同的业务逻辑和行为
2. **性能优先**: 在保持正确性的前提下，追求极致性能
3. **可测试性**: 每个模块都要有对应的单元测试
4. **代码质量**: 遵循现代 C++ 最佳实践，使用静态分析工具

## 参考资料

- [exchange-core 源码](https://github.com/exchange-core/exchange-core)
- [disruptor-cpp 文档](https://github.com/SkynetNext/disruptor-cpp)
- [LMAX Disruptor 论文](https://lmax-exchange.github.io/disruptor/files/Disruptor-1.0.pdf)


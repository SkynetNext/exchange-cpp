# Java 对象内存布局 - int64 成员分析

根据 [Baeldung 文章](https://www.baeldung.com/java-memory-layout) 的观点，本文档详细说明包含 int64 (long) 类型成员的 Java 对象内存布局。

## 1. 基本概念

### 1.1 对象头（Object Header）

在 HotSpot JVM 中，每个对象都包含一个对象头：

- **Mark Word**: 8 字节（64位架构）
  - 存储身份哈希码、偏向锁信息、锁定信息、GC 元数据等
- **Klass Word**: 4 字节（启用压缩引用时）或 8 字节（禁用压缩引用时）
  - 存储类信息：类名、修饰符、父类信息等

**最小对象头大小**：
- 启用压缩引用：12 字节（8 + 4）
- 禁用压缩引用：16 字节（8 + 8）

### 1.2 字段大小

根据 JOL 输出，字段大小如下：
- `long` (int64): **8 字节**
- `int`: 4 字节
- `short`: 2 字节
- `byte`: 1 字节
- `boolean`: 1 字节
- `char`: 2 字节
- `float`: 4 字节
- `double`: 8 字节
- 引用类型: 4 字节（压缩引用）或 8 字节（非压缩引用）

### 1.3 对齐（Alignment）

**默认情况下，JVM 会添加足够的填充使对象大小是 8 的倍数**（可通过 `-XX:ObjectAlignmentInBytes` 调整）。

## 2. 包含 int64 成员的简单对象布局

### 2.1 SimpleLong 类示例

```java
public class SimpleLong {
    private long state;
}
```

### 2.2 内存布局图（启用压缩引用）

```
┌─────────────────────────────────────────────────────────────┐
│                     对象内存布局 (24 字节)                    │
├─────────────────────────────────────────────────────────────┤
│ 偏移量 │ 大小 │ 内容              │ 说明                      │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 0      │ 8    │ Mark Word        │ 对象头 - 第一部分         │
│        │      │                  │ (哈希码、锁、GC信息)       │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 8      │ 4    │ Klass Word       │ 对象头 - 第二部分         │
│        │      │                  │ (类信息，压缩引用)         │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 12     │ 4    │ [填充间隙]       │ 对齐填充                  │
│        │      │ (alignment gap) │                          │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 16     │ 8    │ long state       │ 实例字段                  │
│        │      │                  │                          │
├────────┴──────┴──────────────────┴──────────────────────────┤
│ 总大小: 24 字节 (对象头 12 + 填充 4 + long 8)                │
│ 空间损失: 4 字节内部填充 + 0 字节外部填充 = 4 字节            │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 详细说明

1. **对象头（0-11 字节）**：
   - 0-7: Mark Word (8 字节)
   - 8-11: Klass Word (4 字节，压缩引用)

2. **对齐填充（12-15 字节）**：
   - 4 字节填充，使 `long` 字段从 8 字节对齐的偏移量（16）开始
   - 这有助于提高内存访问效率

3. **实例字段（16-23 字节）**：
   - `long state`: 8 字节

4. **总大小**：
   - 对象头: 12 字节
   - 填充: 4 字节
   - long 字段: 8 字节
   - **总计: 24 字节**（8 的倍数）

## 3. 多个字段的情况（字段打包）

### 3.1 包含 int64 和其他类型的类

```java
public class MixedFields {
    private boolean first;    // 1 字节
    private char second;      // 2 字节
    private double third;     // 8 字节
    private int fourth;       // 4 字节
    private long fifth;       // 8 字节
    private boolean sixth;    // 1 字节
}
```

### 3.2 内存布局图（字段重新排列）

```
┌─────────────────────────────────────────────────────────────┐
│                 对象内存布局 (字段重新排列)                    │
├─────────────────────────────────────────────────────────────┤
│ 偏移量 │ 大小 │ 内容              │ 说明                      │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 0      │ 8    │ Mark Word        │ 对象头                    │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 8      │ 4    │ Klass Word       │ 对象头                    │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 12     │ 4    │ int fourth       │ JVM 重新排列：先放大的     │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 16     │ 8    │ double third     │ 8 字节对齐                │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 24     │ 8    │ long fifth       │ 8 字节对齐                │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 32     │ 2    │ char second      │                          │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 34     │ 1    │ boolean first    │                          │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 35     │ 1    │ boolean sixth    │                          │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 36     │ 4    │ [填充]           │ 对齐到 8 字节边界          │
├────────┴──────┴──────────────────┴──────────────────────────┤
│ 总大小: 40 字节                                              │
│ 注意: 字段顺序与声明顺序不同，JVM 优化了内存布局              │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 字段打包原理

**JVM 会重新排列字段顺序以最小化填充浪费**：
- 优先放置 8 字节字段（double, long）在 8 字节对齐的位置
- 然后放置 4 字节字段（int, float）
- 最后放置较小的字段（short, char, byte, boolean）
- 这样可以减少内部填充空间

## 4. 禁用压缩引用的情况

当使用 `-XX:-UseCompressedOops` 禁用压缩引用时：

### 4.1 SimpleLong 布局变化

```
┌─────────────────────────────────────────────────────────────┐
│             对象内存布局 (禁用压缩引用，32 字节)                │
├─────────────────────────────────────────────────────────────┤
│ 偏移量 │ 大小 │ 内容              │ 说明                      │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 0      │ 8    │ Mark Word        │ 对象头                    │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 8      │ 8    │ Klass Word       │ 对象头（非压缩，8字节）    │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 16     │ 8    │ long state       │ 实例字段                  │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 24     │ 8    │ [填充]           │ 对齐填充                  │
├────────┴──────┴──────────────────┴──────────────────────────┤
│ 总大小: 32 字节 (对象头 16 + long 8 + 填充 8)                │
└─────────────────────────────────────────────────────────────┘
```

**变化**：
- Klass Word 从 4 字节变为 8 字节
- 对象头从 12 字节变为 16 字节
- 总大小从 24 字节变为 32 字节

## 5. 对齐大小调整

### 5.1 使用 `-XX:ObjectAlignmentInBytes=16`

如果设置对齐大小为 16 字节：

```
┌─────────────────────────────────────────────────────────────┐
│         对象内存布局 (对齐大小 16 字节，32 字节)                │
├─────────────────────────────────────────────────────────────┤
│ 偏移量 │ 大小 │ 内容              │ 说明                      │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 0      │ 8    │ Mark Word        │ 对象头                    │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 8      │ 4    │ Klass Word       │ 对象头                    │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 12     │ 4    │ [填充]           │ 使 long 从 16 开始         │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 16     │ 8    │ long state       │ 实例字段                  │
├────────┼──────┼──────────────────┼──────────────────────────┤
│ 24     │ 8    │ [填充]           │ 对齐到 16 字节边界         │
├────────┴──────┴──────────────────┴──────────────────────────┤
│ 总大小: 32 字节                                              │
│ 空间损失: 4 字节内部填充 + 8 字节外部填充 = 12 字节            │
└─────────────────────────────────────────────────────────────┘
```

## 6. 关键要点总结

1. **对象头大小**：
   - 启用压缩引用：12 字节（8 + 4）
   - 禁用压缩引用：16 字节（8 + 8）

2. **int64 (long) 字段**：
   - 占用 8 字节
   - 通常需要 8 字节对齐以获得最佳性能

3. **对齐规则**：
   - 默认对齐到 8 字节边界
   - 可通过 `-XX:ObjectAlignmentInBytes` 调整

4. **字段打包**：
   - JVM 会重新排列字段以最小化填充
   - 大字段（8 字节）优先放在对齐位置

5. **SimpleLong 示例**：
   - 对象头：12 字节
   - 填充：4 字节（使 long 从偏移量 16 开始）
   - long 字段：8 字节
   - **总大小：24 字节**

## 7. 参考

- [Baeldung - Memory Layout of Objects in Java](https://www.baeldung.com/java-memory-layout)
- [JOL (Java Object Layout)](http://openjdk.java.net/projects/code-tools/jol/)
- [Aleksey Shipilëv - Objects Inside Out](https://shipilev.net/jvm/objects-inside-out/)
